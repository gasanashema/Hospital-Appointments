from datetime import datetime
from mongoengine import (
    Document,
    EmbeddedDocument,
    ReferenceField,
    EmbeddedDocumentField,
    StringField,
    BooleanField,
    FloatField,
    DateTimeField,
    ValidationError,
)
from patients.models import Patient
from users.models import User


class Prediction(EmbeddedDocument):
    """
    Embedded prediction generated by the ML model at appointment creation.
    This document is written once and never modified after that.
    """
    # "show" or "no-show"
    predicted_label = StringField(
        required=True,
        choices=["show", "no-show"],
    )
    # Probability of the positive class (show), stored as 0.0–1.0
    predicted_probability = FloatField(required=True, min_value=0.0, max_value=1.0)

    # Model version tag for traceability
    model_version = StringField(default="logistic_v1")

    created_at = DateTimeField(default=datetime.utcnow)


class Appointment(Document):
    """
    MongoDB document representing a scheduled appointment.
    Linked to a patient and a doctor.
    """
    patient = ReferenceField(Patient, required=True)
    doctor = ReferenceField(User, required=True)

    # Combined datetime (date + time) of the appointment
    appointment_date = DateTimeField(required=True)

    # Whether the patient received an SMS reminder before the appointment
    sms_received = BooleanField(default=False)

    # Current status of the appointment
    status = StringField(
        required=True,
        default="pending",
        choices=["pending", "done", "canceled"],
    )

    # Outcome fields — only set when status changes to 'done'
    showed_up = BooleanField(null=True, default=None)
    was_late = BooleanField(null=True, default=None)

    # ML prediction — embedded and read-only after creation
    prediction = EmbeddedDocumentField(Prediction)

    created_at = DateTimeField(default=datetime.utcnow)

    meta = {
        "collection": "appointments",
        "ordering": ["-created_at"],
        "indexes": ["patient", "doctor", "status", "appointment_date"],
    }

    def cancel(self):
        """
        Cancel this appointment. Raises ValidationError if already done.
        """
        if self.status == "done":
            raise ValidationError("Cannot cancel an appointment that is already done.")
        self.status = "canceled"
        self.save()

    def mark_done(self, showed_up: bool, was_late: bool = False):
        """
        Mark appointment as done with outcome data.
        """
        if self.status != "pending":
            raise ValidationError(f"Cannot mark a '{self.status}' appointment as done.")
        self.status = "done"
        self.showed_up = showed_up
        self.was_late = was_late
        self.save()

    def __str__(self):
        return f"Appointment({self.patient}, {self.appointment_date}, {self.status})"
